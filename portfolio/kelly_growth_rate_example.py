# -*- coding: utf-8 -*-
"""kelly-growth-rate-example.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k51teTdVISVHpSuh6FFo8lAQT0BuOXCH
"""

# !pip install numpy
# !pip install cvxpy

import numpy as np
import cvxpy as cvx

# Assume a horse race of 3 horse with the following definitions.
# p = [0.08, 0.5, 0.42] (1.52)
# o = [19, 1.99, 1.3] (1.53)
# Hence, µ from definition:
# µ = [0.52, −0.005, −0.454] (1.54)
# Using Kelly exclusive algorithm on this problem yields the following optimal
# fractions b
# ?
# b
# ? = [0.03030916, 0.0255648, 0.0] (1.55)

P_M = np.array(
      [[0.32822376, 0.67177624],
       [0.87922084, 0.12077919],
       [0.70207   , 0.29793   ],
       [0.27129745, 0.72870255],
       [0.71263921, 0.28736079],
       [0.86146849, 0.13853151],
       [0.64640749, 0.35359249],
       [0.67452425, 0.32547575],
       [0.34954542, 0.65045458],
       [0.77150959, 0.22849041]
       ])

O = np.array(
      [[ 2.18,  1.77],
       [ 1.08, 10.15],
       [ 1.45,  2.75],
       [ 2.85,  1.45],
       [ 1.68,  2.29],
       [ 1.2 ,  4.59],
       [ 1.38,  2.95],
       [ 1.53,  2.5 ],
       [ 2.25,  1.6 ],
       [ 1.2 ,  4.59],
       ])





from itertools import product, chain
def cartesian(*arrays):
    N = len(arrays)
    return np.transpose(np.meshgrid(*arrays, indexing='ij'),
                        np.roll(np.arange(N + 1), -1)).reshape(-1, N)

def build_matrix_R_multi_game(P_M, O, verbose = False, cash = True, cash_payoff = 1.0):


    joint_probs = np.prod(cartesian(*P_M), axis = 1, dtype = np.float64)
    # joint_probs /= np.sum(joint_probs)

    n_assets = np.size(O)
    n_outcomes = np.size(joint_probs)

    '''
    Diagonality expresses the exclusivity of outcmes
    '''
    diags = map(lambda x: np.diag(x), O)
    return_diags = product(*diags)

    #some hardcore chaining to not have to list the product
    return_vector = np.fromiter(chain.from_iterable(chain.from_iterable(return_diags)), dtype=np.float)

    R = np.reshape(return_vector, (n_outcomes, n_assets))
    if cash:
        R = np.insert(R, R.shape[1], cash_payoff, axis=1)

    if verbose:
        print("Returns")
        print(R)

    return joint_probs,  R

p_joint, R = build_matrix_R_multi_game(P_M, O)

p_joint.shape, R.shape

R

np.min(p_joint)

p_joint.shape, R.shape, f.shape, (R @ f).shape, f.shape

f = cvx.Variable(21)

goal = cvx.Maximize(p_joint @ cvx.log(R @ f))
constraints = [cvx.sum(f) == 1, f >= 0]
problem = cvx.Problem(goal, constraints)
problem.solve(solver='ECOS', verbose=True)
f_star = f.value
print(f_star)

f.value

goal.value

(p_joint @ cvx.log(R @ f)).value

# b_eps = 1e-8
# VERBOSE = False




#no cash
# p = np.array([0.7, 0.3])
# R = np.array([
#               [1./0.3, 0],
#               [0, 1./0.7]
#               ])
# f = cvx.Variable(2)
# eps = 0.1
# ##  with cash
# p = np.array([0.7, 0.3])
# R = np.array([
#               [1./(0.3+eps), 0, 1.0],
#               [0, 1./(0.7+eps), 1.0]
#               ])

eps = 0.0
##  with cash
p = np.array([0.3, 0.7])
R = np.array([
              [1./(0.3+eps), 0, 1.0],
              [0, 1./(0.7+eps), 1.0]
              ])
f = cvx.Variable(3)

# R = R - 1
# # µ = [0.52, −0.005, −0.454]

# p = np.array([0.08, 0.5, 0.42])
# R = np.array([
#               [19, 0, 0, 1],
#               [0, 1.99, 0, 1],
#               [0, 0, 1.3, 1]
#               ])
# f = cvx.Variable(4)

# print((p @ R ) - 1)


goal = cvx.Maximize(p @ cvx.log(R @ f))
# constraints = [cvx.sum(f) == 1, f >= 0, f[2]==0]
constraints = [cvx.sum(f) == 1, f >= 0]
# constraints = [cvx.sum(f) == 1, f >= 0]
problem = cvx.Problem(goal, constraints)
problem.solve(solver='ECOS', verbose=True)
f_star = f.value
print(f_star)

print("growth rate")
goal.value

r = np.array([.5, .5])
(r @ cvx.log(R @ f_star)).value

f_star_half = [f_star[0] / 2, f_star[1]/2,(1 - (f_star[0:2] / 2).sum())]
f_star_half

np.sum(f_star_half)

r = np.array([.5, .5])
(r @ cvx.log(R @ f_star_half)).value

R

0.5*np.log((0.35/0.3) + 0.5) + 0.5*np.log((0.15/0.7) + 0.5)

p = np.array([0.7, 0.3])
R = np.array([
              [1./(0.3), 0],
              [0, 1./(0.7)]
              ])
f = cvx.Variable(2)

goal = cvx.Maximize(p @ cvx.log(R @ f))
# constraints = [cvx.sum(f) == 1, f >= 0, f[2]==0]
constraints = [cvx.sum(f) == 1, f >= 0]
# constraints = [cvx.sum(f) == 1, f >= 0]
problem = cvx.Problem(goal, constraints)
problem.solve(solver='ECOS', verbose=True)
f_star = f.value
print(f_star)

print("growth rate")
goal.value

R

R = np.array([
    [1.001, 0.0],
    [0.0, 1.001]          
])

p = np.array([0.2, 0.8])

b = 0.0001
a = 0.1

p_b = 0.23
p_q = 1 - p_b

# frac = edge / odds
#
# frac = E_return / sigma^2
#
# f = E[returns] - (1/2 * Var[returns])
#
# mean = -0.001
# var = 0.0022**2
#
# max(log(Wealth)) ~ E[returns] - (1/2 * Var[returns])
#
# (p*log(R*b)) = p_positive * log(1.01 * f)

returns = [0.0001, -0.00000]

returns = np.array([0.08523702, 0.11503963, 0.10949469, 0.10560127, 0.10845156,
       0.09308553, 0.11348359, 0.10830308, 0.07377966, 0.11418866,
       0.10109413, 0.11836629, 0.11380404, 0.11462659, 0.10814285,
       0.10401955, 0.09159073, 0.12001868, 0.11742602, 0.06639087,
       0.12515302, 0.08715606, 0.11472905, 0.11750081, 0.11742912,
       0.10251486, 0.10809827, 0.09257042, 0.11725336, 0.12804015,
       0.09376243, 0.08117872, 0.09775794, 0.11805271, 0.08933373,
       0.09577033, 0.08982913, 0.08720054, 0.10530512, 0.11124684,
       0.09332286, 0.12606865, 0.11065477, 0.11714153, 0.06879576,
       0.11617406, 0.10188656, 0.11416759, 0.10983466, 0.10656062,
       0.12234931, 0.10061008, 0.06837061, 0.10657659, 0.12058003,
       0.10996933, 0.06340994, 0.09286399, 0.08078931, 0.09891115,
       0.11058852, 0.08226629, 0.11401987, 0.0712592 , 0.10771842,
       0.11393581, 0.11613637, 0.10275188, 0.10456145, 0.11184476,
       0.11496952, 0.1106426 , 0.10981494, 0.09373605, 0.09944198,
       0.11697334, 0.07299735, 0.10087149, 0.08472444, 0.10645963,
       0.09813847, 0.08600114, 0.1138431 , 0.12699692, 0.11343062,
       0.10154592, 0.10513744, 0.10564342, 0.1170339 , 0.1258819 ,
       0.12845953, 0.13159437, 0.09784722, 0.09935886, 0.10897279,
       0.11040697, 0.10926732, 0.09166524, 0.09278107, 0.11266911])

returns = np.array([[-2.22234113e-03],
       [ 1.66473644e-03],
       [ 2.47386421e-03],
       [ 1.67342621e-03],
       [ 2.15247492e-03],
       [ 1.32053518e-03],
       [ 1.57196489e-03],
       [ 1.50854147e-03],
       [-5.21270147e-03],
       [ 4.81205922e-04],
       [ 1.71732458e-03],
       [-1.03122187e-03],
       [ 1.86855013e-03],
       [-1.99548407e-05],
       [-1.11865789e-03],
       [-2.27299372e-03],
       [-1.49836657e-03],
       [ 7.43815485e-04],
       [-1.79545252e-03],
       [-5.98782371e-04],
       [ 1.53758810e-03],
       [ 3.86548330e-03],
       [ 3.56077631e-03],
       [ 2.59044646e-03],
       [-1.73746963e-03],
       [-2.35119888e-03],
       [ 4.36294526e-03],
       [ 4.58127442e-04],
       [ 2.15357056e-03],
       [-4.78129816e-04],
       [-4.41782244e-03],
       [-5.98144368e-04],
       [ 3.98411955e-03],
       [ 7.06803237e-04],
       [ 1.95169780e-03],
       [-7.95144612e-04],
       [-5.95810173e-05],
       [ 2.59813504e-04],
       [-3.90615728e-04],
       [-1.27793520e-03],
       [ 1.00958276e-03],
       [-8.37201661e-04],
       [ 8.28640270e-04],
       [-6.19407119e-03],
       [ 1.77976273e-03],
       [ 9.15928230e-04],
       [ 4.67887519e-03],
       [-2.96836582e-03],
       [ 1.99245192e-03],
       [ 2.38283168e-03],
       [ 2.95204340e-03],
       [ 2.70952982e-04],
       [ 3.01892088e-04],
       [-6.44266095e-05],
       [-9.34145810e-04],
       [-1.42609995e-03],
       [-8.38798015e-04],
       [-2.52343008e-03],
       [ 1.19582064e-04],
       [-2.08378153e-05],
       [ 1.63054002e-03],
       [-1.27231431e-03],
       [ 4.16071447e-03],
       [-1.80246798e-05],
       [-1.36583962e-03],
       [ 3.33373609e-03],
       [-2.26202383e-03],
       [ 2.15159733e-03],
       [-7.25034277e-04],
       [ 1.28707906e-03],
       [ 9.57463032e-04],
       [ 2.45350195e-03],
       [ 3.67814463e-03],
       [ 4.07459484e-03],
       [ 5.28936328e-03],
       [ 3.76473267e-03],
       [-5.08033335e-03],
       [-2.25633834e-03],
       [-2.96702531e-05],
       [-9.61649930e-04],
       [ 3.49507008e-03],
       [-1.51207152e-03],
       [-3.86723102e-04],
       [-2.21146546e-03],
       [ 5.07342508e-04],
       [ 9.93379638e-04],
       [ 2.34611824e-03],
       [ 3.12735424e-03],
       [-3.79704016e-03],
       [-1.62211223e-03],
       [ 3.02760503e-03],
       [ 2.58651346e-03],
       [ 8.84730692e-04],
       [ 7.23657822e-04],
       [ 1.12007303e-03],
       [ 3.37256812e-03],
       [ 1.32807008e-03],
       [ 1.41117468e-03],
       [ 1.83657730e-03],
       [ 9.34984868e-04]])

returns = returns.flatten()

returns

len(returns[(returns >= 1e-3)])

len(returns[(returns >= 1e-4) & (returns < 1e-3)])

len(returns[(returns <= -1e-3)])

len(returns[(returns <= -1e-4) & (returns > -1e-3)])

len(returns[(returns < 1e-4) & (returns > -1e-4)])

p.sum()

R = np.array([
  [1.001,1],
  [1.0001,1],
  [1.0,1],
  [0.9999,1],
  [0.993,1],
])
p = np.array([0.43, 0.16, 0.06, 0.11, 0.24])
# p = np.array([0.43, 0.16, 0.41])

f = cvx.Variable(2)

goal = cvx.Maximize(p @ cvx.log(R @ f))
# constraints = [cvx.sum(f) == 1, f >= 0, f[2]==0]
constraints = [cvx.sum(f) == 1, f >= 0]
# constraints = []
# constraints = [cvx.sum(f) == 1, f >=0]
problem = cvx.Problem(goal, constraints)
problem.solve(solver='ECOS', verbose=True, feastol=1.6e-10)
f_star = f.value
print(f_star)

mean = np.mean(returns)
var = np.var(returns)

fraction = 4
f = mean - var/2
f_btc = 1/fraction * f
f_cash = 1 - f_btc
f_star = np.array([f_btc, f_cash])
f_star

x = 0.6
y = 0.6

a = 0.4
b = 0.4

p = np.array([(1-x)*(1-y), x*y, (1-x)*y, x*(1-y)])
R = np.array([
              [1./(1-a), 0, 1./(1-b), 0],
              [0, 1./(a), 0, 1./(b)],
              [1./(1-a), 0, 0, 1./(b)],
              [0, 1./(a), 1./(1-b), 0],
              ])
f = cvx.Variable(4)

goal = cvx.Maximize(p @ cvx.log(R @ f))
# constraints = [cvx.sum(f) == 1, f >= 0, f[2]==0]
constraints = [cvx.sum(f) == 1, f >= 0]
# constraints = [cvx.sum(f) == 1, f >= 0]
problem = cvx.Problem(goal, constraints)
problem.solve(solver='ECOS', verbose=True)
f_star = f.value
print(f_star)

print("growth rate")
goal.value

p = np.array([(1-x), x])
R = np.array([
              [1./(1-a), 0],
              [0, 1./(a)]
              ])
f = cvx.Variable(2)

goal = cvx.Maximize(p @ cvx.log(R @ f))
# constraints = [cvx.sum(f) == 1, f >= 0, f[2]==0]
constraints = [cvx.sum(f) == 1, f >= 0]
# constraints = [cvx.sum(f) == 1, f >= 0]
problem = cvx.Problem(goal, constraints)
problem.solve(solver='ECOS', verbose=True)
f_star = f.value
print(f_star)

print("growth rate")
gr1 = goal.value

p = np.array([(1-y), y])
R = np.array([
              [1./(1-b), 0],
              [0, 1./(b)]
              ])
f = cvx.Variable(2)

goal = cvx.Maximize(p @ cvx.log(R @ f))
# constraints = [cvx.sum(f) == 1, f >= 0, f[2]==0]
constraints = [cvx.sum(f) == 1, f >= 0]
# constraints = [cvx.sum(f) == 1, f >= 0]
problem = cvx.Problem(goal, constraints)
problem.solve(solver='ECOS', verbose=True)
f_star = f.value
print(f_star)

print("growth rate")
goal.value

np.log(0.5*goal.value*2)